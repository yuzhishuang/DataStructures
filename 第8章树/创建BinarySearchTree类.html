<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    (function(){
       //  二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值
       //  创建BinarySearchTree类
       function BinarySearchTree () {
       	var Node = function (key) {
       		this.key = key;
       		this.left = null;
       		this.right = null;
       	};
       	var root = null;
       	//  向树中插入一个值
       	//  将节点加在非根节点的其他位置。这种情况下，需要一个辅助函数
       	var insertNode = function (node, newNode) {
       		if (newNode.key < node.key) {
       			if (node.left === null) {
       				node.left = newNode;
       			} else {
       				insertNode(node.left, newNode);
       			}
       		} else {
       			if (node.right === null) {
       				node.right = newNode;
       			} else {
       				insertNode(node.right, newNode);
       			}
       		}
       	};
       	this.insert = function (key) {
       		var newNode = new Node(key);
       		if (root === null) {
       			root = newNode;
       		} else {
       			insertNode(root, newNode);
       		}
       	};
       	//  中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的访问所有节点。
       	//  由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数
       	//  回调函数用来定义我们对遍历到的每个节点进行的操作
       	var inOrderTraverseNode = function (node, callback) {
       		if (node !== null) {
       			inOrderTraverseNode(node.left, callback);
       			callback(node.key);
       			inOrderTraverseNode(node.right, callback);
       		}
       	};
       	this.inOrderTraverse = function (callback) {
       		inOrderTraverseNode(root, callback);
       	};
       	//  先序排列是以优先于后代节点的顺序访问每个节点的。先序排列的一种应用是打印一个结构化的文档
       	//  辅助函数preOrderTraverseNode的实现
       	var preOrderTraverseNode = function (node, callback) {
       		if (node !== null) {
       			callback(node.key);
       			preOrderTraverseNode(node.left, callback);
       			preOrderTraverseNode(node.right, callback);
       		}
       	}
       	this.preOrderTraverse = function (callback) {
       		preOrderTraverseNode(root, callback);
       	}
       }
       //  测试代码
       var tree = new BinarySearchTree();
       tree.insert(11);
       tree.insert(7);
       tree.insert(15);
       tree.insert(5);
       tree.insert(3);
       tree.insert(9);
       tree.insert(8);
       tree.insert(10);
       tree.insert(13);
       tree.insert(12);
       tree.insert(14);
       tree.insert(20);
       tree.insert(18);
       tree.insert(25);
       tree.insert(6);
       function printNode (value) {
       	console.log(value);
       }
       //  中序排列
       console.log('中序排列');
       debugger
       tree.inOrderTraverse(printNode);
       //  先序排列
       console.log('先序排列');
       tree.preOrderTraverse(printNode);
    })();
</script>
</body>
</html>